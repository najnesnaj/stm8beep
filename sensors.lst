                                      1 ;--------------------------------------------------------
                                      2 ; File Created by SDCC : free open source ANSI-C Compiler
                                      3 ; Version 3.4.0 #8981 (Jul 11 2014) (Linux)
                                      4 ; This file was generated Fri Apr 21 13:12:02 2017
                                      5 ;--------------------------------------------------------
                                      6 	.module sensors
                                      7 	.optsdcc -mstm8
                                      8 	
                                      9 ;--------------------------------------------------------
                                     10 ; Public variables in this module
                                     11 ;--------------------------------------------------------
                                     12 	.globl _segmentMap
                                     13 	.globl _main
                                     14 	.globl _timer_isr
                                     15 	.globl _rt_one_second_increment
                                     16 	.globl _clock
                                     17 	.globl _tm1637DisplayDecimal
                                     18 	.globl _tm1637Init
                                     19 	.globl _InitializeUART
                                     20 	.globl _InitializeI2C
                                     21 	.globl _i2c_read_register
                                     22 	.globl _print_byte_hex
                                     23 	.globl _i2c_set_start_ack
                                     24 	.globl _i2c_send_address
                                     25 	.globl _print_UCHAR_hex
                                     26 	.globl _UARTPrintF
                                     27 	.globl _i2c_send_reg
                                     28 	.globl _i2c_set_stop
                                     29 	.globl _i2c_set_nak
                                     30 	.globl _i2c_read
                                     31 	.globl _delay
                                     32 	.globl _InitializeSystemClock
                                     33 	.globl _delayTenMicro
                                     34 	.globl _minuten
                                     35 	.globl _seconden
                                     36 	.globl _internteller
                                     37 	.globl _real_time
                                     38 	.globl _tm1637SetBrightness
                                     39 	.globl __tm1637Start
                                     40 	.globl __tm1637Stop
                                     41 	.globl __tm1637ReadResult
                                     42 	.globl __tm1637WriteByte
                                     43 	.globl __tm1637ClkHigh
                                     44 	.globl __tm1637ClkLow
                                     45 	.globl __tm1637DioHigh
                                     46 	.globl __tm1637DioLow
                                     47 ;--------------------------------------------------------
                                     48 ; ram data
                                     49 ;--------------------------------------------------------
                                     50 	.area DATA
      000000                         51 _real_time::
      000000                         52 	.ds 4
      000004                         53 _internteller::
      000004                         54 	.ds 2
      000006                         55 _seconden::
      000006                         56 	.ds 2
      000008                         57 _minuten::
      000008                         58 	.ds 2
                                     59 ;--------------------------------------------------------
                                     60 ; ram data
                                     61 ;--------------------------------------------------------
                                     62 	.area INITIALIZED
                                     63 ;--------------------------------------------------------
                                     64 ; Stack segment in internal ram 
                                     65 ;--------------------------------------------------------
                                     66 	.area	SSEG
      000000                         67 __start__stack:
      000000                         68 	.ds	1
                                     69 
                                     70 ;--------------------------------------------------------
                                     71 ; absolute external ram data
                                     72 ;--------------------------------------------------------
                                     73 	.area DABS (ABS)
                                     74 ;--------------------------------------------------------
                                     75 ; interrupt vector 
                                     76 ;--------------------------------------------------------
                                     77 	.area HOME
      000000                         78 __interrupt_vect:
      000000 82v00u00u00             79 	int s_GSINIT ;reset
      000004 82 00 00 00             80 	int 0x0000 ;trap
      000008 82 00 00 00             81 	int 0x0000 ;int0
      00000C 82 00 00 00             82 	int 0x0000 ;int1
      000010 82 00 00 00             83 	int 0x0000 ;int2
      000014 82 00 00 00             84 	int 0x0000 ;int3
      000018 82 00 00 00             85 	int 0x0000 ;int4
      00001C 82 00 00 00             86 	int 0x0000 ;int5
      000020 82v00u04u7F             87 	int _timer_isr ;int6
      000024 82 00 00 00             88 	int 0x0000 ;int7
      000028 82 00 00 00             89 	int 0x0000 ;int8
      00002C 82 00 00 00             90 	int 0x0000 ;int9
      000030 82 00 00 00             91 	int 0x0000 ;int10
      000034 82 00 00 00             92 	int 0x0000 ;int11
      000038 82 00 00 00             93 	int 0x0000 ;int12
      00003C 82 00 00 00             94 	int 0x0000 ;int13
      000040 82 00 00 00             95 	int 0x0000 ;int14
      000044 82 00 00 00             96 	int 0x0000 ;int15
      000048 82 00 00 00             97 	int 0x0000 ;int16
      00004C 82 00 00 00             98 	int 0x0000 ;int17
      000050 82 00 00 00             99 	int 0x0000 ;int18
      000054 82 00 00 00            100 	int 0x0000 ;int19
      000058 82 00 00 00            101 	int 0x0000 ;int20
      00005C 82 00 00 00            102 	int 0x0000 ;int21
      000060 82 00 00 00            103 	int 0x0000 ;int22
      000064 82 00 00 00            104 	int 0x0000 ;int23
      000068 82 00 00 00            105 	int 0x0000 ;int24
      00006C 82 00 00 00            106 	int 0x0000 ;int25
      000070 82 00 00 00            107 	int 0x0000 ;int26
      000074 82 00 00 00            108 	int 0x0000 ;int27
      000078 82 00 00 00            109 	int 0x0000 ;int28
      00007C 82 00 00 00            110 	int 0x0000 ;int29
                                    111 ;--------------------------------------------------------
                                    112 ; global & static initialisations
                                    113 ;--------------------------------------------------------
                                    114 	.area HOME
                                    115 	.area GSINIT
                                    116 	.area GSFINAL
                                    117 	.area GSINIT
      000000                        118 __sdcc_gs_init_startup:
      000000                        119 __sdcc_init_data:
                                    120 ; stm8_genXINIT() start
      000000 AEr00r00         [ 2]  121 	ldw x, #l_DATA
      000003 27 07            [ 1]  122 	jreq	00002$
      000005                        123 00001$:
      000005 72 4FuFFuFF      [ 1]  124 	clr (s_DATA - 1, x)
      000009 5A               [ 2]  125 	decw x
      00000A 26 F9            [ 1]  126 	jrne	00001$
      00000C                        127 00002$:
      00000C AEr00r00         [ 2]  128 	ldw	x, #l_INITIALIZER
      00000F 27 09            [ 1]  129 	jreq	00004$
      000011                        130 00003$:
      000011 D6uFFuFF         [ 1]  131 	ld	a, (s_INITIALIZER - 1, x)
      000014 D7uFFuFF         [ 1]  132 	ld	(s_INITIALIZED - 1, x), a
      000017 5A               [ 2]  133 	decw	x
      000018 26 F7            [ 1]  134 	jrne	00003$
      00001A                        135 00004$:
                                    136 ; stm8_genXINIT() end
                                    137 	.area GSFINAL
      000000 CCr00r80         [ 2]  138 	jp	__sdcc_program_startup
                                    139 ;--------------------------------------------------------
                                    140 ; Home
                                    141 ;--------------------------------------------------------
                                    142 	.area HOME
                                    143 	.area HOME
      000080                        144 __sdcc_program_startup:
      000080 CCr04r9D         [ 2]  145 	jp	_main
                                    146 ;	return from main will return to caller
                                    147 ;--------------------------------------------------------
                                    148 ; code
                                    149 ;--------------------------------------------------------
                                    150 	.area CODE
                                    151 ;	sensors.c: 24: void delayTenMicro (void) {
                                    152 ;	-----------------------------------------
                                    153 ;	 function delayTenMicro
                                    154 ;	-----------------------------------------
      000000                        155 _delayTenMicro:
                                    156 ;	sensors.c: 26: for (a = 0; a < 50; ++a)
      000000 A6 32            [ 1]  157 	ld	a, #0x32
      000002                        158 00104$:
                                    159 ;	sensors.c: 27: __asm__("nop");
      000002 9D               [ 1]  160 	nop
      000003 4A               [ 1]  161 	dec	a
                                    162 ;	sensors.c: 26: for (a = 0; a < 50; ++a)
      000004 4D               [ 1]  163 	tnz	a
      000005 26 FB            [ 1]  164 	jrne	00104$
      000007 81               [ 4]  165 	ret
                                    166 ;	sensors.c: 30: void InitializeSystemClock() {
                                    167 ;	-----------------------------------------
                                    168 ;	 function InitializeSystemClock
                                    169 ;	-----------------------------------------
      000008                        170 _InitializeSystemClock:
                                    171 ;	sensors.c: 31: CLK_ICKR = 0;                       //  Reset the Internal Clock Register.
      000008 AE 50 C0         [ 2]  172 	ldw	x, #0x50c0
      00000B 7F               [ 1]  173 	clr	(x)
                                    174 ;	sensors.c: 32: CLK_ICKR = CLK_HSIEN;               //  Enable the HSI.
      00000C AE 50 C0         [ 2]  175 	ldw	x, #0x50c0
      00000F A6 01            [ 1]  176 	ld	a, #0x01
      000011 F7               [ 1]  177 	ld	(x), a
                                    178 ;	sensors.c: 33: CLK_ECKR = 0;                       //  Disable the external clock.
      000012 AE 50 C1         [ 2]  179 	ldw	x, #0x50c1
      000015 7F               [ 1]  180 	clr	(x)
                                    181 ;	sensors.c: 34: while ((CLK_ICKR & CLK_HSIRDY) == 0);       //  Wait for the HSI to be ready for use.
      000016                        182 00101$:
      000016 AE 50 C0         [ 2]  183 	ldw	x, #0x50c0
      000019 F6               [ 1]  184 	ld	a, (x)
      00001A A5 02            [ 1]  185 	bcp	a, #0x02
      00001C 27 F8            [ 1]  186 	jreq	00101$
                                    187 ;	sensors.c: 35: CLK_CKDIVR = 0;                     //  Ensure the clocks are running at full speed.
      00001E AE 50 C6         [ 2]  188 	ldw	x, #0x50c6
      000021 7F               [ 1]  189 	clr	(x)
                                    190 ;	sensors.c: 36: CLK_PCKENR1 = 0xff;                 //  Enable all peripheral clocks.
      000022 AE 50 C7         [ 2]  191 	ldw	x, #0x50c7
      000025 A6 FF            [ 1]  192 	ld	a, #0xff
      000027 F7               [ 1]  193 	ld	(x), a
                                    194 ;	sensors.c: 37: CLK_PCKENR2 = 0xff;                 //  Ditto.
      000028 AE 50 CA         [ 2]  195 	ldw	x, #0x50ca
      00002B A6 FF            [ 1]  196 	ld	a, #0xff
      00002D F7               [ 1]  197 	ld	(x), a
                                    198 ;	sensors.c: 38: CLK_CCOR = 0;                       //  Turn off CCO.
      00002E AE 50 C9         [ 2]  199 	ldw	x, #0x50c9
      000031 7F               [ 1]  200 	clr	(x)
                                    201 ;	sensors.c: 39: CLK_HSITRIMR = 0;                   //  Turn off any HSIU trimming.
      000032 AE 50 CC         [ 2]  202 	ldw	x, #0x50cc
      000035 7F               [ 1]  203 	clr	(x)
                                    204 ;	sensors.c: 40: CLK_SWIMCCR = 0;                    //  Set SWIM to run at clock / 2.
      000036 AE 50 CD         [ 2]  205 	ldw	x, #0x50cd
      000039 7F               [ 1]  206 	clr	(x)
                                    207 ;	sensors.c: 41: CLK_SWR = 0xe1;                     //  Use HSI as the clock source.
      00003A AE 50 C4         [ 2]  208 	ldw	x, #0x50c4
      00003D A6 E1            [ 1]  209 	ld	a, #0xe1
      00003F F7               [ 1]  210 	ld	(x), a
                                    211 ;	sensors.c: 42: CLK_SWCR = 0;                       //  Reset the clock switch control register.
      000040 AE 50 C5         [ 2]  212 	ldw	x, #0x50c5
      000043 7F               [ 1]  213 	clr	(x)
                                    214 ;	sensors.c: 43: CLK_SWCR = CLK_SWEN;                //  Enable switching.
      000044 AE 50 C5         [ 2]  215 	ldw	x, #0x50c5
      000047 A6 02            [ 1]  216 	ld	a, #0x02
      000049 F7               [ 1]  217 	ld	(x), a
                                    218 ;	sensors.c: 44: while ((CLK_SWCR & CLK_SWBSY) != 0);        //  Pause while the clock switch is busy.
      00004A                        219 00104$:
      00004A AE 50 C5         [ 2]  220 	ldw	x, #0x50c5
      00004D F6               [ 1]  221 	ld	a, (x)
      00004E 44               [ 1]  222 	srl	a
      00004F 25 F9            [ 1]  223 	jrc	00104$
      000051 81               [ 4]  224 	ret
                                    225 ;	sensors.c: 46: void delay (int time_ms) {
                                    226 ;	-----------------------------------------
                                    227 ;	 function delay
                                    228 ;	-----------------------------------------
      000052                        229 _delay:
      000052 52 0A            [ 2]  230 	sub	sp, #10
                                    231 ;	sensors.c: 48: for (x = 0; x < 1036*time_ms; ++x)
      000054 5F               [ 1]  232 	clrw	x
      000055 1F 03            [ 2]  233 	ldw	(0x03, sp), x
      000057 1F 01            [ 2]  234 	ldw	(0x01, sp), x
      000059 1E 0D            [ 2]  235 	ldw	x, (0x0d, sp)
      00005B 89               [ 2]  236 	pushw	x
      00005C 4B 0C            [ 1]  237 	push	#0x0c
      00005E 4B 04            [ 1]  238 	push	#0x04
      000060 CDr00r00         [ 4]  239 	call	__mulint
      000063 5B 04            [ 2]  240 	addw	sp, #4
      000065 1F 09            [ 2]  241 	ldw	(0x09, sp), x
      000067                        242 00103$:
      000067 16 09            [ 2]  243 	ldw	y, (0x09, sp)
      000069 17 07            [ 2]  244 	ldw	(0x07, sp), y
      00006B 7B 07            [ 1]  245 	ld	a, (0x07, sp)
      00006D 49               [ 1]  246 	rlc	a
      00006E 4F               [ 1]  247 	clr	a
      00006F A2 00            [ 1]  248 	sbc	a, #0x00
      000071 6B 06            [ 1]  249 	ld	(0x06, sp), a
      000073 6B 05            [ 1]  250 	ld	(0x05, sp), a
      000075 1E 03            [ 2]  251 	ldw	x, (0x03, sp)
      000077 13 07            [ 2]  252 	cpw	x, (0x07, sp)
      000079 7B 02            [ 1]  253 	ld	a, (0x02, sp)
      00007B 12 06            [ 1]  254 	sbc	a, (0x06, sp)
      00007D 7B 01            [ 1]  255 	ld	a, (0x01, sp)
      00007F 12 05            [ 1]  256 	sbc	a, (0x05, sp)
      000081 2E 17            [ 1]  257 	jrsge	00105$
                                    258 ;	sensors.c: 49: __asm__("nop");
      000083 9D               [ 1]  259 	nop
                                    260 ;	sensors.c: 48: for (x = 0; x < 1036*time_ms; ++x)
      000084 16 03            [ 2]  261 	ldw	y, (0x03, sp)
      000086 72 A9 00 01      [ 2]  262 	addw	y, #0x0001
      00008A 7B 02            [ 1]  263 	ld	a, (0x02, sp)
      00008C A9 00            [ 1]  264 	adc	a, #0x00
      00008E 97               [ 1]  265 	ld	xl, a
      00008F 7B 01            [ 1]  266 	ld	a, (0x01, sp)
      000091 A9 00            [ 1]  267 	adc	a, #0x00
      000093 95               [ 1]  268 	ld	xh, a
      000094 17 03            [ 2]  269 	ldw	(0x03, sp), y
      000096 1F 01            [ 2]  270 	ldw	(0x01, sp), x
      000098 20 CD            [ 2]  271 	jra	00103$
      00009A                        272 00105$:
      00009A 5B 0A            [ 2]  273 	addw	sp, #10
      00009C 81               [ 4]  274 	ret
                                    275 ;	sensors.c: 51: void i2c_read (unsigned char *x) {
                                    276 ;	-----------------------------------------
                                    277 ;	 function i2c_read
                                    278 ;	-----------------------------------------
      00009D                        279 _i2c_read:
                                    280 ;	sensors.c: 52: while ((I2C_SR1 & I2C_RXNE) == 0);
      00009D                        281 00101$:
      00009D AE 52 17         [ 2]  282 	ldw	x, #0x5217
      0000A0 F6               [ 1]  283 	ld	a, (x)
      0000A1 A5 40            [ 1]  284 	bcp	a, #0x40
      0000A3 27 F8            [ 1]  285 	jreq	00101$
                                    286 ;	sensors.c: 53: *x = I2C_DR;
      0000A5 16 03            [ 2]  287 	ldw	y, (0x03, sp)
      0000A7 AE 52 16         [ 2]  288 	ldw	x, #0x5216
      0000AA F6               [ 1]  289 	ld	a, (x)
      0000AB 90 F7            [ 1]  290 	ld	(y), a
      0000AD 81               [ 4]  291 	ret
                                    292 ;	sensors.c: 55: void i2c_set_nak (void) {
                                    293 ;	-----------------------------------------
                                    294 ;	 function i2c_set_nak
                                    295 ;	-----------------------------------------
      0000AE                        296 _i2c_set_nak:
                                    297 ;	sensors.c: 56: I2C_CR2 &= ~I2C_ACK;
      0000AE AE 52 11         [ 2]  298 	ldw	x, #0x5211
      0000B1 F6               [ 1]  299 	ld	a, (x)
      0000B2 A4 FB            [ 1]  300 	and	a, #0xfb
      0000B4 F7               [ 1]  301 	ld	(x), a
      0000B5 81               [ 4]  302 	ret
                                    303 ;	sensors.c: 58: void i2c_set_stop (void) {
                                    304 ;	-----------------------------------------
                                    305 ;	 function i2c_set_stop
                                    306 ;	-----------------------------------------
      0000B6                        307 _i2c_set_stop:
                                    308 ;	sensors.c: 59: I2C_CR2 |= I2C_STOP;
      0000B6 AE 52 11         [ 2]  309 	ldw	x, #0x5211
      0000B9 F6               [ 1]  310 	ld	a, (x)
      0000BA AA 02            [ 1]  311 	or	a, #0x02
      0000BC F7               [ 1]  312 	ld	(x), a
      0000BD 81               [ 4]  313 	ret
                                    314 ;	sensors.c: 61: void i2c_send_reg (UCHAR addr) {
                                    315 ;	-----------------------------------------
                                    316 ;	 function i2c_send_reg
                                    317 ;	-----------------------------------------
      0000BE                        318 _i2c_send_reg:
      0000BE 52 02            [ 2]  319 	sub	sp, #2
                                    320 ;	sensors.c: 63: reg = I2C_SR1;
      0000C0 AE 52 17         [ 2]  321 	ldw	x, #0x5217
      0000C3 F6               [ 1]  322 	ld	a, (x)
      0000C4 5F               [ 1]  323 	clrw	x
      0000C5 97               [ 1]  324 	ld	xl, a
      0000C6 1F 01            [ 2]  325 	ldw	(0x01, sp), x
                                    326 ;	sensors.c: 64: reg = I2C_SR3;
      0000C8 AE 52 19         [ 2]  327 	ldw	x, #0x5219
      0000CB F6               [ 1]  328 	ld	a, (x)
      0000CC 5F               [ 1]  329 	clrw	x
      0000CD 97               [ 1]  330 	ld	xl, a
      0000CE 1F 01            [ 2]  331 	ldw	(0x01, sp), x
                                    332 ;	sensors.c: 65: I2C_DR = addr;
      0000D0 AE 52 16         [ 2]  333 	ldw	x, #0x5216
      0000D3 7B 05            [ 1]  334 	ld	a, (0x05, sp)
      0000D5 F7               [ 1]  335 	ld	(x), a
                                    336 ;	sensors.c: 66: while ((I2C_SR1 & I2C_TXE) == 0);
      0000D6                        337 00101$:
      0000D6 AE 52 17         [ 2]  338 	ldw	x, #0x5217
      0000D9 F6               [ 1]  339 	ld	a, (x)
      0000DA 48               [ 1]  340 	sll	a
      0000DB 24 F9            [ 1]  341 	jrnc	00101$
      0000DD 5B 02            [ 2]  342 	addw	sp, #2
      0000DF 81               [ 4]  343 	ret
                                    344 ;	sensors.c: 70: void UARTPrintF (char *message) {
                                    345 ;	-----------------------------------------
                                    346 ;	 function UARTPrintF
                                    347 ;	-----------------------------------------
      0000E0                        348 _UARTPrintF:
                                    349 ;	sensors.c: 71: char *ch = message;
      0000E0 16 03            [ 2]  350 	ldw	y, (0x03, sp)
                                    351 ;	sensors.c: 72: while (*ch) {
      0000E2                        352 00104$:
      0000E2 90 F6            [ 1]  353 	ld	a, (y)
      0000E4 4D               [ 1]  354 	tnz	a
      0000E5 27 0F            [ 1]  355 	jreq	00107$
                                    356 ;	sensors.c: 73: UART1_DR = (unsigned char) *ch;     //  Put the next character into the data transmission register.
      0000E7 AE 52 31         [ 2]  357 	ldw	x, #0x5231
      0000EA F7               [ 1]  358 	ld	(x), a
                                    359 ;	sensors.c: 74: while ((UART1_SR & SR_TXE) == 0);   //  Wait for transmission to complete.
      0000EB                        360 00101$:
      0000EB AE 52 30         [ 2]  361 	ldw	x, #0x5230
      0000EE F6               [ 1]  362 	ld	a, (x)
      0000EF 48               [ 1]  363 	sll	a
      0000F0 24 F9            [ 1]  364 	jrnc	00101$
                                    365 ;	sensors.c: 75: ch++;                               //  Grab the next character.
      0000F2 90 5C            [ 2]  366 	incw	y
      0000F4 20 EC            [ 2]  367 	jra	00104$
      0000F6                        368 00107$:
      0000F6 81               [ 4]  369 	ret
                                    370 ;	sensors.c: 79: void print_UCHAR_hex (unsigned char buffer) {
                                    371 ;	-----------------------------------------
                                    372 ;	 function print_UCHAR_hex
                                    373 ;	-----------------------------------------
      0000F7                        374 _print_UCHAR_hex:
      0000F7 52 0C            [ 2]  375 	sub	sp, #12
                                    376 ;	sensors.c: 82: a = (buffer >> 4);
      0000F9 7B 0F            [ 1]  377 	ld	a, (0x0f, sp)
      0000FB 4E               [ 1]  378 	swap	a
      0000FC A4 0F            [ 1]  379 	and	a, #0x0f
      0000FE 5F               [ 1]  380 	clrw	x
      0000FF 97               [ 1]  381 	ld	xl, a
                                    382 ;	sensors.c: 83: if (a > 9)
      000100 A3 00 09         [ 2]  383 	cpw	x, #0x0009
      000103 2D 07            [ 1]  384 	jrsle	00102$
                                    385 ;	sensors.c: 84: a = a + 'a' - 10;
      000105 1C 00 57         [ 2]  386 	addw	x, #0x0057
      000108 1F 01            [ 2]  387 	ldw	(0x01, sp), x
      00010A 20 05            [ 2]  388 	jra	00103$
      00010C                        389 00102$:
                                    390 ;	sensors.c: 86: a += '0';
      00010C 1C 00 30         [ 2]  391 	addw	x, #0x0030
      00010F 1F 01            [ 2]  392 	ldw	(0x01, sp), x
      000111                        393 00103$:
                                    394 ;	sensors.c: 87: b = buffer & 0x0f;
      000111 7B 0F            [ 1]  395 	ld	a, (0x0f, sp)
      000113 A4 0F            [ 1]  396 	and	a, #0x0f
      000115 5F               [ 1]  397 	clrw	x
      000116 97               [ 1]  398 	ld	xl, a
                                    399 ;	sensors.c: 88: if (b > 9)
      000117 A3 00 09         [ 2]  400 	cpw	x, #0x0009
      00011A 2D 07            [ 1]  401 	jrsle	00105$
                                    402 ;	sensors.c: 89: b = b + 'a' - 10;
      00011C 1C 00 57         [ 2]  403 	addw	x, #0x0057
      00011F 1F 0B            [ 2]  404 	ldw	(0x0b, sp), x
      000121 20 05            [ 2]  405 	jra	00106$
      000123                        406 00105$:
                                    407 ;	sensors.c: 91: b += '0';
      000123 1C 00 30         [ 2]  408 	addw	x, #0x0030
      000126 1F 0B            [ 2]  409 	ldw	(0x0b, sp), x
      000128                        410 00106$:
                                    411 ;	sensors.c: 92: message[0] = a;
      000128 90 96            [ 1]  412 	ldw	y, sp
      00012A 72 A9 00 03      [ 2]  413 	addw	y, #3
      00012E 7B 02            [ 1]  414 	ld	a, (0x02, sp)
      000130 90 F7            [ 1]  415 	ld	(y), a
                                    416 ;	sensors.c: 93: message[1] = b;
      000132 93               [ 1]  417 	ldw	x, y
      000133 5C               [ 2]  418 	incw	x
      000134 7B 0C            [ 1]  419 	ld	a, (0x0c, sp)
      000136 F7               [ 1]  420 	ld	(x), a
                                    421 ;	sensors.c: 94: message[2] = 0;
      000137 93               [ 1]  422 	ldw	x, y
      000138 5C               [ 2]  423 	incw	x
      000139 5C               [ 2]  424 	incw	x
      00013A 7F               [ 1]  425 	clr	(x)
                                    426 ;	sensors.c: 95: UARTPrintF (message);
      00013B 90 89            [ 2]  427 	pushw	y
      00013D CDr00rE0         [ 4]  428 	call	_UARTPrintF
      000140 5B 02            [ 2]  429 	addw	sp, #2
      000142 5B 0C            [ 2]  430 	addw	sp, #12
      000144 81               [ 4]  431 	ret
                                    432 ;	sensors.c: 98: void i2c_send_address (UCHAR addr, UCHAR mode) {
                                    433 ;	-----------------------------------------
                                    434 ;	 function i2c_send_address
                                    435 ;	-----------------------------------------
      000145                        436 _i2c_send_address:
      000145 52 03            [ 2]  437 	sub	sp, #3
                                    438 ;	sensors.c: 100: reg = I2C_SR1;
      000147 AE 52 17         [ 2]  439 	ldw	x, #0x5217
      00014A F6               [ 1]  440 	ld	a, (x)
      00014B 5F               [ 1]  441 	clrw	x
      00014C 97               [ 1]  442 	ld	xl, a
      00014D 1F 01            [ 2]  443 	ldw	(0x01, sp), x
                                    444 ;	sensors.c: 101: I2C_DR = (addr << 1) | mode;
      00014F 7B 06            [ 1]  445 	ld	a, (0x06, sp)
      000151 48               [ 1]  446 	sll	a
      000152 1A 07            [ 1]  447 	or	a, (0x07, sp)
      000154 AE 52 16         [ 2]  448 	ldw	x, #0x5216
      000157 F7               [ 1]  449 	ld	(x), a
                                    450 ;	sensors.c: 102: if (mode == I2C_READ) {
      000158 7B 07            [ 1]  451 	ld	a, (0x07, sp)
      00015A A1 01            [ 1]  452 	cp	a, #0x01
      00015C 26 06            [ 1]  453 	jrne	00127$
      00015E A6 01            [ 1]  454 	ld	a, #0x01
      000160 6B 03            [ 1]  455 	ld	(0x03, sp), a
      000162 20 02            [ 2]  456 	jra	00128$
      000164                        457 00127$:
      000164 0F 03            [ 1]  458 	clr	(0x03, sp)
      000166                        459 00128$:
      000166 0D 03            [ 1]  460 	tnz	(0x03, sp)
      000168 27 08            [ 1]  461 	jreq	00103$
                                    462 ;	sensors.c: 103: I2C_OARL = 0;
      00016A AE 52 13         [ 2]  463 	ldw	x, #0x5213
      00016D 7F               [ 1]  464 	clr	(x)
                                    465 ;	sensors.c: 104: I2C_OARH = 0;
      00016E AE 52 14         [ 2]  466 	ldw	x, #0x5214
      000171 7F               [ 1]  467 	clr	(x)
                                    468 ;	sensors.c: 107: while ((I2C_SR1 & I2C_ADDR) == 0);
      000172                        469 00103$:
                                    470 ;	sensors.c: 100: reg = I2C_SR1;
      000172 AE 52 17         [ 2]  471 	ldw	x, #0x5217
      000175 F6               [ 1]  472 	ld	a, (x)
                                    473 ;	sensors.c: 107: while ((I2C_SR1 & I2C_ADDR) == 0);
      000176 A5 02            [ 1]  474 	bcp	a, #0x02
      000178 27 F8            [ 1]  475 	jreq	00103$
                                    476 ;	sensors.c: 108: if (mode == I2C_READ)
      00017A 0D 03            [ 1]  477 	tnz	(0x03, sp)
      00017C 27 06            [ 1]  478 	jreq	00108$
                                    479 ;	sensors.c: 109: UNSET (I2C_SR1, I2C_ADDR);
      00017E A4 FD            [ 1]  480 	and	a, #0xfd
      000180 AE 52 17         [ 2]  481 	ldw	x, #0x5217
      000183 F7               [ 1]  482 	ld	(x), a
      000184                        483 00108$:
      000184 5B 03            [ 2]  484 	addw	sp, #3
      000186 81               [ 4]  485 	ret
                                    486 ;	sensors.c: 112: void i2c_set_start_ack (void) {
                                    487 ;	-----------------------------------------
                                    488 ;	 function i2c_set_start_ack
                                    489 ;	-----------------------------------------
      000187                        490 _i2c_set_start_ack:
                                    491 ;	sensors.c: 113: I2C_CR2 = I2C_ACK | I2C_START;
      000187 AE 52 11         [ 2]  492 	ldw	x, #0x5211
      00018A A6 05            [ 1]  493 	ld	a, #0x05
      00018C F7               [ 1]  494 	ld	(x), a
                                    495 ;	sensors.c: 114: while ((I2C_SR1 & I2C_SB) == 0);
      00018D                        496 00101$:
      00018D AE 52 17         [ 2]  497 	ldw	x, #0x5217
      000190 F6               [ 1]  498 	ld	a, (x)
      000191 44               [ 1]  499 	srl	a
      000192 24 F9            [ 1]  500 	jrnc	00101$
      000194 81               [ 4]  501 	ret
                                    502 ;	sensors.c: 121: void print_byte_hex (unsigned char buffer) {
                                    503 ;	-----------------------------------------
                                    504 ;	 function print_byte_hex
                                    505 ;	-----------------------------------------
      000195                        506 _print_byte_hex:
      000195 52 0C            [ 2]  507 	sub	sp, #12
                                    508 ;	sensors.c: 124: a = (buffer >> 4);
      000197 7B 0F            [ 1]  509 	ld	a, (0x0f, sp)
      000199 4E               [ 1]  510 	swap	a
      00019A A4 0F            [ 1]  511 	and	a, #0x0f
      00019C 5F               [ 1]  512 	clrw	x
      00019D 97               [ 1]  513 	ld	xl, a
                                    514 ;	sensors.c: 125: if (a > 9)
      00019E A3 00 09         [ 2]  515 	cpw	x, #0x0009
      0001A1 2D 07            [ 1]  516 	jrsle	00102$
                                    517 ;	sensors.c: 126: a = a + 'a' - 10;
      0001A3 1C 00 57         [ 2]  518 	addw	x, #0x0057
      0001A6 1F 03            [ 2]  519 	ldw	(0x03, sp), x
      0001A8 20 05            [ 2]  520 	jra	00103$
      0001AA                        521 00102$:
                                    522 ;	sensors.c: 128: a += '0'; 
      0001AA 1C 00 30         [ 2]  523 	addw	x, #0x0030
      0001AD 1F 03            [ 2]  524 	ldw	(0x03, sp), x
      0001AF                        525 00103$:
                                    526 ;	sensors.c: 129: b = buffer & 0x0f;
      0001AF 7B 0F            [ 1]  527 	ld	a, (0x0f, sp)
      0001B1 A4 0F            [ 1]  528 	and	a, #0x0f
      0001B3 5F               [ 1]  529 	clrw	x
      0001B4 97               [ 1]  530 	ld	xl, a
                                    531 ;	sensors.c: 130: if (b > 9)
      0001B5 A3 00 09         [ 2]  532 	cpw	x, #0x0009
      0001B8 2D 07            [ 1]  533 	jrsle	00105$
                                    534 ;	sensors.c: 131: b = b + 'a' - 10;
      0001BA 1C 00 57         [ 2]  535 	addw	x, #0x0057
      0001BD 1F 01            [ 2]  536 	ldw	(0x01, sp), x
      0001BF 20 05            [ 2]  537 	jra	00106$
      0001C1                        538 00105$:
                                    539 ;	sensors.c: 133: b += '0'; 
      0001C1 1C 00 30         [ 2]  540 	addw	x, #0x0030
      0001C4 1F 01            [ 2]  541 	ldw	(0x01, sp), x
      0001C6                        542 00106$:
                                    543 ;	sensors.c: 134: message[0] = a;
      0001C6 90 96            [ 1]  544 	ldw	y, sp
      0001C8 72 A9 00 05      [ 2]  545 	addw	y, #5
      0001CC 7B 04            [ 1]  546 	ld	a, (0x04, sp)
      0001CE 90 F7            [ 1]  547 	ld	(y), a
                                    548 ;	sensors.c: 135: message[1] = b;
      0001D0 93               [ 1]  549 	ldw	x, y
      0001D1 5C               [ 2]  550 	incw	x
      0001D2 7B 02            [ 1]  551 	ld	a, (0x02, sp)
      0001D4 F7               [ 1]  552 	ld	(x), a
                                    553 ;	sensors.c: 136: message[2] = 0;
      0001D5 93               [ 1]  554 	ldw	x, y
      0001D6 5C               [ 2]  555 	incw	x
      0001D7 5C               [ 2]  556 	incw	x
      0001D8 7F               [ 1]  557 	clr	(x)
                                    558 ;	sensors.c: 137: UARTPrintF (message);
      0001D9 90 89            [ 2]  559 	pushw	y
      0001DB CDr00rE0         [ 4]  560 	call	_UARTPrintF
      0001DE 5B 02            [ 2]  561 	addw	sp, #2
      0001E0 5B 0C            [ 2]  562 	addw	sp, #12
      0001E2 81               [ 4]  563 	ret
                                    564 ;	sensors.c: 141: unsigned char i2c_read_register (UCHAR addr, UCHAR rg) {
                                    565 ;	-----------------------------------------
                                    566 ;	 function i2c_read_register
                                    567 ;	-----------------------------------------
      0001E3                        568 _i2c_read_register:
      0001E3 52 02            [ 2]  569 	sub	sp, #2
                                    570 ;	sensors.c: 144: i2c_set_start_ack ();
      0001E5 CDr01r87         [ 4]  571 	call	_i2c_set_start_ack
                                    572 ;	sensors.c: 145: i2c_send_address (addr, I2C_WRITE);
      0001E8 4B 00            [ 1]  573 	push	#0x00
      0001EA 7B 06            [ 1]  574 	ld	a, (0x06, sp)
      0001EC 88               [ 1]  575 	push	a
      0001ED CDr01r45         [ 4]  576 	call	_i2c_send_address
      0001F0 5B 02            [ 2]  577 	addw	sp, #2
                                    578 ;	sensors.c: 146: i2c_send_reg (rg);
      0001F2 7B 06            [ 1]  579 	ld	a, (0x06, sp)
      0001F4 88               [ 1]  580 	push	a
      0001F5 CDr00rBE         [ 4]  581 	call	_i2c_send_reg
      0001F8 84               [ 1]  582 	pop	a
                                    583 ;	sensors.c: 147: i2c_set_start_ack ();
      0001F9 CDr01r87         [ 4]  584 	call	_i2c_set_start_ack
                                    585 ;	sensors.c: 148: i2c_send_address (addr, I2C_READ);
      0001FC 4B 01            [ 1]  586 	push	#0x01
      0001FE 7B 06            [ 1]  587 	ld	a, (0x06, sp)
      000200 88               [ 1]  588 	push	a
      000201 CDr01r45         [ 4]  589 	call	_i2c_send_address
      000204 5B 02            [ 2]  590 	addw	sp, #2
                                    591 ;	sensors.c: 149: reg = I2C_SR1;
      000206 AE 52 17         [ 2]  592 	ldw	x, #0x5217
      000209 F6               [ 1]  593 	ld	a, (x)
      00020A 6B 01            [ 1]  594 	ld	(0x01, sp), a
                                    595 ;	sensors.c: 150: reg = I2C_SR3;
      00020C AE 52 19         [ 2]  596 	ldw	x, #0x5219
      00020F F6               [ 1]  597 	ld	a, (x)
      000210 6B 01            [ 1]  598 	ld	(0x01, sp), a
                                    599 ;	sensors.c: 151: i2c_set_nak ();
      000212 CDr00rAE         [ 4]  600 	call	_i2c_set_nak
                                    601 ;	sensors.c: 152: i2c_set_stop ();
      000215 CDr00rB6         [ 4]  602 	call	_i2c_set_stop
                                    603 ;	sensors.c: 153: i2c_read (&x);
      000218 96               [ 1]  604 	ldw	x, sp
      000219 5C               [ 2]  605 	incw	x
      00021A 5C               [ 2]  606 	incw	x
      00021B 89               [ 2]  607 	pushw	x
      00021C CDr00r9D         [ 4]  608 	call	_i2c_read
      00021F 5B 02            [ 2]  609 	addw	sp, #2
                                    610 ;	sensors.c: 154: return (x);
      000221 7B 02            [ 1]  611 	ld	a, (0x02, sp)
      000223 5B 02            [ 2]  612 	addw	sp, #2
      000225 81               [ 4]  613 	ret
                                    614 ;	sensors.c: 157: void InitializeI2C (void) {
                                    615 ;	-----------------------------------------
                                    616 ;	 function InitializeI2C
                                    617 ;	-----------------------------------------
      000226                        618 _InitializeI2C:
                                    619 ;	sensors.c: 158: I2C_CR1 = 0;   //  Disable I2C before configuration starts. PE bit is bit 0
      000226 AE 52 10         [ 2]  620 	ldw	x, #0x5210
      000229 7F               [ 1]  621 	clr	(x)
                                    622 ;	sensors.c: 162: I2C_FREQR = 16;                     //  Set the internal clock frequency (MHz).
      00022A AE 52 12         [ 2]  623 	ldw	x, #0x5212
      00022D A6 10            [ 1]  624 	ld	a, #0x10
      00022F F7               [ 1]  625 	ld	(x), a
                                    626 ;	sensors.c: 163: UNSET (I2C_CCRH, I2C_FS);           //  I2C running is standard mode.
      000230 72 17 52 1C      [ 1]  627 	bres	0x521c, #7
                                    628 ;	sensors.c: 165: I2C_CCRL = 0xa0;                    //  SCL clock speed is 50 kHz.
      000234 AE 52 1B         [ 2]  629 	ldw	x, #0x521b
      000237 A6 A0            [ 1]  630 	ld	a, #0xa0
      000239 F7               [ 1]  631 	ld	(x), a
                                    632 ;	sensors.c: 167: I2C_CCRH &= 0x00;	// Clears lower 4 bits "CCR"
      00023A AE 52 1C         [ 2]  633 	ldw	x, #0x521c
      00023D 7F               [ 1]  634 	clr	(x)
                                    635 ;	sensors.c: 171: UNSET (I2C_OARH, I2C_ADDMODE);      //  7 bit address mode.
      00023E 72 17 52 14      [ 1]  636 	bres	0x5214, #7
                                    637 ;	sensors.c: 172: SET (I2C_OARH, I2C_ADDCONF);        //  Docs say this must always be 1.
      000242 AE 52 14         [ 2]  638 	ldw	x, #0x5214
      000245 F6               [ 1]  639 	ld	a, (x)
      000246 AA 40            [ 1]  640 	or	a, #0x40
      000248 F7               [ 1]  641 	ld	(x), a
                                    642 ;	sensors.c: 176: I2C_TRISER = 17;
      000249 AE 52 1D         [ 2]  643 	ldw	x, #0x521d
      00024C A6 11            [ 1]  644 	ld	a, #0x11
      00024E F7               [ 1]  645 	ld	(x), a
                                    646 ;	sensors.c: 184: I2C_CR1 = I2C_PE;	// Enables port
      00024F AE 52 10         [ 2]  647 	ldw	x, #0x5210
      000252 A6 01            [ 1]  648 	ld	a, #0x01
      000254 F7               [ 1]  649 	ld	(x), a
      000255 81               [ 4]  650 	ret
                                    651 ;	sensors.c: 190: void InitializeUART() {
                                    652 ;	-----------------------------------------
                                    653 ;	 function InitializeUART
                                    654 ;	-----------------------------------------
      000256                        655 _InitializeUART:
                                    656 ;	sensors.c: 200: UART1_CR1 = 0;
      000256 AE 52 34         [ 2]  657 	ldw	x, #0x5234
      000259 7F               [ 1]  658 	clr	(x)
                                    659 ;	sensors.c: 201: UART1_CR2 = 0;
      00025A AE 52 35         [ 2]  660 	ldw	x, #0x5235
      00025D 7F               [ 1]  661 	clr	(x)
                                    662 ;	sensors.c: 202: UART1_CR4 = 0;
      00025E AE 52 37         [ 2]  663 	ldw	x, #0x5237
      000261 7F               [ 1]  664 	clr	(x)
                                    665 ;	sensors.c: 203: UART1_CR3 = 0;
      000262 AE 52 36         [ 2]  666 	ldw	x, #0x5236
      000265 7F               [ 1]  667 	clr	(x)
                                    668 ;	sensors.c: 204: UART1_CR5 = 0;
      000266 AE 52 38         [ 2]  669 	ldw	x, #0x5238
      000269 7F               [ 1]  670 	clr	(x)
                                    671 ;	sensors.c: 205: UART1_GTR = 0;
      00026A AE 52 39         [ 2]  672 	ldw	x, #0x5239
      00026D 7F               [ 1]  673 	clr	(x)
                                    674 ;	sensors.c: 206: UART1_PSCR = 0;
      00026E AE 52 3A         [ 2]  675 	ldw	x, #0x523a
      000271 7F               [ 1]  676 	clr	(x)
                                    677 ;	sensors.c: 210: UNSET (UART1_CR1, CR1_M);        //  8 Data bits.
      000272 AE 52 34         [ 2]  678 	ldw	x, #0x5234
      000275 F6               [ 1]  679 	ld	a, (x)
      000276 A4 EF            [ 1]  680 	and	a, #0xef
      000278 F7               [ 1]  681 	ld	(x), a
                                    682 ;	sensors.c: 211: UNSET (UART1_CR1, CR1_PCEN);     //  Disable parity.
      000279 AE 52 34         [ 2]  683 	ldw	x, #0x5234
      00027C F6               [ 1]  684 	ld	a, (x)
      00027D A4 FB            [ 1]  685 	and	a, #0xfb
      00027F F7               [ 1]  686 	ld	(x), a
                                    687 ;	sensors.c: 212: UNSET (UART1_CR3, CR3_STOPH);    //  1 stop bit.
      000280 AE 52 36         [ 2]  688 	ldw	x, #0x5236
      000283 F6               [ 1]  689 	ld	a, (x)
      000284 A4 DF            [ 1]  690 	and	a, #0xdf
      000286 F7               [ 1]  691 	ld	(x), a
                                    692 ;	sensors.c: 213: UNSET (UART1_CR3, CR3_STOPL);    //  1 stop bit.
      000287 AE 52 36         [ 2]  693 	ldw	x, #0x5236
      00028A F6               [ 1]  694 	ld	a, (x)
      00028B A4 EF            [ 1]  695 	and	a, #0xef
      00028D F7               [ 1]  696 	ld	(x), a
                                    697 ;	sensors.c: 214: UART1_BRR2 = 0x0a;      //  Set the baud rate registers to 115200 baud
      00028E AE 52 33         [ 2]  698 	ldw	x, #0x5233
      000291 A6 0A            [ 1]  699 	ld	a, #0x0a
      000293 F7               [ 1]  700 	ld	(x), a
                                    701 ;	sensors.c: 215: UART1_BRR1 = 0x08;      //  based upon a 16 MHz system clock.
      000294 AE 52 32         [ 2]  702 	ldw	x, #0x5232
      000297 A6 08            [ 1]  703 	ld	a, #0x08
      000299 F7               [ 1]  704 	ld	(x), a
                                    705 ;	sensors.c: 219: UNSET (UART1_CR2, CR2_TEN);      //  Disable transmit.
      00029A AE 52 35         [ 2]  706 	ldw	x, #0x5235
      00029D F6               [ 1]  707 	ld	a, (x)
      00029E A4 F7            [ 1]  708 	and	a, #0xf7
      0002A0 F7               [ 1]  709 	ld	(x), a
                                    710 ;	sensors.c: 220: UNSET (UART1_CR2, CR2_REN);      //  Disable receive.
      0002A1 AE 52 35         [ 2]  711 	ldw	x, #0x5235
      0002A4 F6               [ 1]  712 	ld	a, (x)
      0002A5 A4 FB            [ 1]  713 	and	a, #0xfb
      0002A7 F7               [ 1]  714 	ld	(x), a
                                    715 ;	sensors.c: 224: SET (UART1_CR3, CR3_CPOL);
      0002A8 AE 52 36         [ 2]  716 	ldw	x, #0x5236
      0002AB F6               [ 1]  717 	ld	a, (x)
      0002AC AA 04            [ 1]  718 	or	a, #0x04
      0002AE F7               [ 1]  719 	ld	(x), a
                                    720 ;	sensors.c: 225: SET (UART1_CR3, CR3_CPHA);
      0002AF AE 52 36         [ 2]  721 	ldw	x, #0x5236
      0002B2 F6               [ 1]  722 	ld	a, (x)
      0002B3 AA 02            [ 1]  723 	or	a, #0x02
      0002B5 F7               [ 1]  724 	ld	(x), a
                                    725 ;	sensors.c: 226: SET (UART1_CR3, CR3_LBCL);
      0002B6 72 10 52 36      [ 1]  726 	bset	0x5236, #0
                                    727 ;	sensors.c: 230: SET (UART1_CR2, CR2_TEN);
      0002BA AE 52 35         [ 2]  728 	ldw	x, #0x5235
      0002BD F6               [ 1]  729 	ld	a, (x)
      0002BE AA 08            [ 1]  730 	or	a, #0x08
      0002C0 F7               [ 1]  731 	ld	(x), a
                                    732 ;	sensors.c: 231: SET (UART1_CR2, CR2_REN);
      0002C1 AE 52 35         [ 2]  733 	ldw	x, #0x5235
      0002C4 F6               [ 1]  734 	ld	a, (x)
      0002C5 AA 04            [ 1]  735 	or	a, #0x04
      0002C7 F7               [ 1]  736 	ld	(x), a
                                    737 ;	sensors.c: 232: UART1_CR3 = CR3_CLKEN;
      0002C8 AE 52 36         [ 2]  738 	ldw	x, #0x5236
      0002CB A6 08            [ 1]  739 	ld	a, #0x08
      0002CD F7               [ 1]  740 	ld	(x), a
      0002CE 81               [ 4]  741 	ret
                                    742 ;	sensors.c: 260: void tm1637Init(void)
                                    743 ;	-----------------------------------------
                                    744 ;	 function tm1637Init
                                    745 ;	-----------------------------------------
      0002CF                        746 _tm1637Init:
                                    747 ;	sensors.c: 262: tm1637SetBrightness(8);
      0002CF 4B 08            [ 1]  748 	push	#0x08
      0002D1 CDr03r6F         [ 4]  749 	call	_tm1637SetBrightness
      0002D4 84               [ 1]  750 	pop	a
      0002D5 81               [ 4]  751 	ret
                                    752 ;	sensors.c: 267: void tm1637DisplayDecimal(u8 TT,unsigned int displaySeparator)
                                    753 ;	-----------------------------------------
                                    754 ;	 function tm1637DisplayDecimal
                                    755 ;	-----------------------------------------
      0002D6                        756 _tm1637DisplayDecimal:
      0002D6 52 0F            [ 2]  757 	sub	sp, #15
                                    758 ;	sensors.c: 269: unsigned int v = TT ;
      0002D8 5F               [ 1]  759 	clrw	x
      0002D9 7B 12            [ 1]  760 	ld	a, (0x12, sp)
      0002DB 97               [ 1]  761 	ld	xl, a
      0002DC 1F 05            [ 2]  762 	ldw	(0x05, sp), x
                                    763 ;	sensors.c: 275: for (ii = 0; ii < 4; ++ii) {
      0002DE 96               [ 1]  764 	ldw	x, sp
      0002DF 5C               [ 2]  765 	incw	x
      0002E0 1F 09            [ 2]  766 	ldw	(0x09, sp), x
      0002E2 AEr04rFE         [ 2]  767 	ldw	x, #_segmentMap+0
      0002E5 1F 0D            [ 2]  768 	ldw	(0x0d, sp), x
      0002E7 90 5F            [ 1]  769 	clrw	y
      0002E9                        770 00106$:
                                    771 ;	sensors.c: 276: digitArr[ii] = segmentMap[v % 10];
      0002E9 93               [ 1]  772 	ldw	x, y
      0002EA 72 FB 09         [ 2]  773 	addw	x, (0x09, sp)
      0002ED 1F 0B            [ 2]  774 	ldw	(0x0b, sp), x
      0002EF 90 89            [ 2]  775 	pushw	y
      0002F1 1E 07            [ 2]  776 	ldw	x, (0x07, sp)
      0002F3 90 AE 00 0A      [ 2]  777 	ldw	y, #0x000a
      0002F7 65               [ 2]  778 	divw	x, y
      0002F8 93               [ 1]  779 	ldw	x, y
      0002F9 90 85            [ 2]  780 	popw	y
      0002FB 72 FB 0D         [ 2]  781 	addw	x, (0x0d, sp)
      0002FE F6               [ 1]  782 	ld	a, (x)
      0002FF 1E 0B            [ 2]  783 	ldw	x, (0x0b, sp)
      000301 F7               [ 1]  784 	ld	(x), a
                                    785 ;	sensors.c: 277: if (ii == 2 && displaySeparator) {
      000302 90 A3 00 02      [ 2]  786 	cpw	y, #0x0002
      000306 26 0C            [ 1]  787 	jrne	00102$
      000308 1E 13            [ 2]  788 	ldw	x, (0x13, sp)
      00030A 27 08            [ 1]  789 	jreq	00102$
                                    790 ;	sensors.c: 278: digitArr[ii] |= 1 << 7;
      00030C 1E 0B            [ 2]  791 	ldw	x, (0x0b, sp)
      00030E F6               [ 1]  792 	ld	a, (x)
      00030F AA 80            [ 1]  793 	or	a, #0x80
      000311 1E 0B            [ 2]  794 	ldw	x, (0x0b, sp)
      000313 F7               [ 1]  795 	ld	(x), a
      000314                        796 00102$:
                                    797 ;	sensors.c: 280: v /= 10;
      000314 90 89            [ 2]  798 	pushw	y
      000316 1E 07            [ 2]  799 	ldw	x, (0x07, sp)
      000318 90 AE 00 0A      [ 2]  800 	ldw	y, #0x000a
      00031C 65               [ 2]  801 	divw	x, y
      00031D 90 85            [ 2]  802 	popw	y
      00031F 1F 05            [ 2]  803 	ldw	(0x05, sp), x
                                    804 ;	sensors.c: 275: for (ii = 0; ii < 4; ++ii) {
      000321 90 5C            [ 2]  805 	incw	y
      000323 90 A3 00 04      [ 2]  806 	cpw	y, #0x0004
      000327 25 C0            [ 1]  807 	jrc	00106$
                                    808 ;	sensors.c: 283: _tm1637Start();
      000329 CDr03r81         [ 4]  809 	call	__tm1637Start
                                    810 ;	sensors.c: 284: _tm1637WriteByte(0x40);
      00032C 4B 40            [ 1]  811 	push	#0x40
      00032E CDr03rD5         [ 4]  812 	call	__tm1637WriteByte
      000331 84               [ 1]  813 	pop	a
                                    814 ;	sensors.c: 285: _tm1637ReadResult();
      000332 CDr03rBA         [ 4]  815 	call	__tm1637ReadResult
                                    816 ;	sensors.c: 286: _tm1637Stop();
      000335 CDr03r93         [ 4]  817 	call	__tm1637Stop
                                    818 ;	sensors.c: 288: _tm1637Start();
      000338 CDr03r81         [ 4]  819 	call	__tm1637Start
                                    820 ;	sensors.c: 289: _tm1637WriteByte(0xc0);
      00033B 4B C0            [ 1]  821 	push	#0xc0
      00033D CDr03rD5         [ 4]  822 	call	__tm1637WriteByte
      000340 84               [ 1]  823 	pop	a
                                    824 ;	sensors.c: 290: _tm1637ReadResult();
      000341 CDr03rBA         [ 4]  825 	call	__tm1637ReadResult
                                    826 ;	sensors.c: 292: for (ii = 0; ii < 4; ++ii) {
      000344 5F               [ 1]  827 	clrw	x
      000345 1F 07            [ 2]  828 	ldw	(0x07, sp), x
      000347                        829 00108$:
                                    830 ;	sensors.c: 293: _tm1637WriteByte(digitArr[3 - ii]);
      000347 7B 08            [ 1]  831 	ld	a, (0x08, sp)
      000349 6B 0F            [ 1]  832 	ld	(0x0f, sp), a
      00034B A6 03            [ 1]  833 	ld	a, #0x03
      00034D 10 0F            [ 1]  834 	sub	a, (0x0f, sp)
      00034F 5F               [ 1]  835 	clrw	x
      000350 97               [ 1]  836 	ld	xl, a
      000351 72 FB 09         [ 2]  837 	addw	x, (0x09, sp)
      000354 F6               [ 1]  838 	ld	a, (x)
      000355 88               [ 1]  839 	push	a
      000356 CDr03rD5         [ 4]  840 	call	__tm1637WriteByte
      000359 84               [ 1]  841 	pop	a
                                    842 ;	sensors.c: 294: _tm1637ReadResult();
      00035A CDr03rBA         [ 4]  843 	call	__tm1637ReadResult
                                    844 ;	sensors.c: 292: for (ii = 0; ii < 4; ++ii) {
      00035D 1E 07            [ 2]  845 	ldw	x, (0x07, sp)
      00035F 5C               [ 2]  846 	incw	x
      000360 1F 07            [ 2]  847 	ldw	(0x07, sp), x
      000362 1E 07            [ 2]  848 	ldw	x, (0x07, sp)
      000364 A3 00 04         [ 2]  849 	cpw	x, #0x0004
      000367 25 DE            [ 1]  850 	jrc	00108$
                                    851 ;	sensors.c: 297: _tm1637Stop();
      000369 CDr03r93         [ 4]  852 	call	__tm1637Stop
      00036C 5B 0F            [ 2]  853 	addw	sp, #15
      00036E 81               [ 4]  854 	ret
                                    855 ;	sensors.c: 302: void tm1637SetBrightness(char brightness)
                                    856 ;	-----------------------------------------
                                    857 ;	 function tm1637SetBrightness
                                    858 ;	-----------------------------------------
      00036F                        859 _tm1637SetBrightness:
                                    860 ;	sensors.c: 309: _tm1637Start();
      00036F CDr03r81         [ 4]  861 	call	__tm1637Start
                                    862 ;	sensors.c: 310: _tm1637WriteByte(0x87 + brightness);
      000372 7B 03            [ 1]  863 	ld	a, (0x03, sp)
      000374 AB 87            [ 1]  864 	add	a, #0x87
      000376 88               [ 1]  865 	push	a
      000377 CDr03rD5         [ 4]  866 	call	__tm1637WriteByte
      00037A 84               [ 1]  867 	pop	a
                                    868 ;	sensors.c: 311: _tm1637ReadResult();
      00037B CDr03rBA         [ 4]  869 	call	__tm1637ReadResult
                                    870 ;	sensors.c: 312: _tm1637Stop();
      00037E CCr03r93         [ 2]  871 	jp	__tm1637Stop
                                    872 ;	sensors.c: 315: void _tm1637Start(void)
                                    873 ;	-----------------------------------------
                                    874 ;	 function _tm1637Start
                                    875 ;	-----------------------------------------
      000381                        876 __tm1637Start:
                                    877 ;	sensors.c: 317: _tm1637ClkHigh();
      000381 CDr04r13         [ 4]  878 	call	__tm1637ClkHigh
                                    879 ;	sensors.c: 318: _tm1637DioHigh();
      000384 CDr04r23         [ 4]  880 	call	__tm1637DioHigh
                                    881 ;	sensors.c: 319: delay(5);
      000387 4B 05            [ 1]  882 	push	#0x05
      000389 4B 00            [ 1]  883 	push	#0x00
      00038B CDr00r52         [ 4]  884 	call	_delay
      00038E 5B 02            [ 2]  885 	addw	sp, #2
                                    886 ;	sensors.c: 320: _tm1637DioLow();
      000390 CCr04r2B         [ 2]  887 	jp	__tm1637DioLow
                                    888 ;	sensors.c: 323: void _tm1637Stop(void)
                                    889 ;	-----------------------------------------
                                    890 ;	 function _tm1637Stop
                                    891 ;	-----------------------------------------
      000393                        892 __tm1637Stop:
                                    893 ;	sensors.c: 325: _tm1637ClkLow();
      000393 CDr04r1B         [ 4]  894 	call	__tm1637ClkLow
                                    895 ;	sensors.c: 326: delay(5);
      000396 4B 05            [ 1]  896 	push	#0x05
      000398 4B 00            [ 1]  897 	push	#0x00
      00039A CDr00r52         [ 4]  898 	call	_delay
      00039D 5B 02            [ 2]  899 	addw	sp, #2
                                    900 ;	sensors.c: 327: _tm1637DioLow();
      00039F CDr04r2B         [ 4]  901 	call	__tm1637DioLow
                                    902 ;	sensors.c: 328: delay(5);
      0003A2 4B 05            [ 1]  903 	push	#0x05
      0003A4 4B 00            [ 1]  904 	push	#0x00
      0003A6 CDr00r52         [ 4]  905 	call	_delay
      0003A9 5B 02            [ 2]  906 	addw	sp, #2
                                    907 ;	sensors.c: 329: _tm1637ClkHigh();
      0003AB CDr04r13         [ 4]  908 	call	__tm1637ClkHigh
                                    909 ;	sensors.c: 330: delay(5);
      0003AE 4B 05            [ 1]  910 	push	#0x05
      0003B0 4B 00            [ 1]  911 	push	#0x00
      0003B2 CDr00r52         [ 4]  912 	call	_delay
      0003B5 5B 02            [ 2]  913 	addw	sp, #2
                                    914 ;	sensors.c: 331: _tm1637DioHigh();
      0003B7 CCr04r23         [ 2]  915 	jp	__tm1637DioHigh
                                    916 ;	sensors.c: 334: void _tm1637ReadResult(void)
                                    917 ;	-----------------------------------------
                                    918 ;	 function _tm1637ReadResult
                                    919 ;	-----------------------------------------
      0003BA                        920 __tm1637ReadResult:
                                    921 ;	sensors.c: 336: _tm1637ClkLow();
      0003BA CDr04r1B         [ 4]  922 	call	__tm1637ClkLow
                                    923 ;	sensors.c: 337: delay(5);
      0003BD 4B 05            [ 1]  924 	push	#0x05
      0003BF 4B 00            [ 1]  925 	push	#0x00
      0003C1 CDr00r52         [ 4]  926 	call	_delay
      0003C4 5B 02            [ 2]  927 	addw	sp, #2
                                    928 ;	sensors.c: 339: _tm1637ClkHigh();
      0003C6 CDr04r13         [ 4]  929 	call	__tm1637ClkHigh
                                    930 ;	sensors.c: 340: delay(5);
      0003C9 4B 05            [ 1]  931 	push	#0x05
      0003CB 4B 00            [ 1]  932 	push	#0x00
      0003CD CDr00r52         [ 4]  933 	call	_delay
      0003D0 5B 02            [ 2]  934 	addw	sp, #2
                                    935 ;	sensors.c: 341: _tm1637ClkLow();
      0003D2 CCr04r1B         [ 2]  936 	jp	__tm1637ClkLow
                                    937 ;	sensors.c: 344: void _tm1637WriteByte(unsigned char b)
                                    938 ;	-----------------------------------------
                                    939 ;	 function _tm1637WriteByte
                                    940 ;	-----------------------------------------
      0003D5                        941 __tm1637WriteByte:
      0003D5 52 02            [ 2]  942 	sub	sp, #2
                                    943 ;	sensors.c: 346: for (ii = 0; ii < 8; ++ii) {
      0003D7 5F               [ 1]  944 	clrw	x
      0003D8 1F 01            [ 2]  945 	ldw	(0x01, sp), x
      0003DA                        946 00105$:
                                    947 ;	sensors.c: 347: _tm1637ClkLow();
      0003DA CDr04r1B         [ 4]  948 	call	__tm1637ClkLow
                                    949 ;	sensors.c: 348: if (b & 0x01) {
      0003DD 7B 05            [ 1]  950 	ld	a, (0x05, sp)
      0003DF 44               [ 1]  951 	srl	a
      0003E0 24 05            [ 1]  952 	jrnc	00102$
                                    953 ;	sensors.c: 349: _tm1637DioHigh();
      0003E2 CDr04r23         [ 4]  954 	call	__tm1637DioHigh
      0003E5 20 03            [ 2]  955 	jra	00103$
      0003E7                        956 00102$:
                                    957 ;	sensors.c: 352: _tm1637DioLow();
      0003E7 CDr04r2B         [ 4]  958 	call	__tm1637DioLow
      0003EA                        959 00103$:
                                    960 ;	sensors.c: 354: delay(15);
      0003EA 4B 0F            [ 1]  961 	push	#0x0f
      0003EC 4B 00            [ 1]  962 	push	#0x00
      0003EE CDr00r52         [ 4]  963 	call	_delay
      0003F1 5B 02            [ 2]  964 	addw	sp, #2
                                    965 ;	sensors.c: 355: b >>= 1;
      0003F3 7B 05            [ 1]  966 	ld	a, (0x05, sp)
      0003F5 44               [ 1]  967 	srl	a
      0003F6 6B 05            [ 1]  968 	ld	(0x05, sp), a
                                    969 ;	sensors.c: 356: _tm1637ClkHigh();
      0003F8 CDr04r13         [ 4]  970 	call	__tm1637ClkHigh
                                    971 ;	sensors.c: 357: delay(15);
      0003FB 4B 0F            [ 1]  972 	push	#0x0f
      0003FD 4B 00            [ 1]  973 	push	#0x00
      0003FF CDr00r52         [ 4]  974 	call	_delay
      000402 5B 02            [ 2]  975 	addw	sp, #2
                                    976 ;	sensors.c: 346: for (ii = 0; ii < 8; ++ii) {
      000404 1E 01            [ 2]  977 	ldw	x, (0x01, sp)
      000406 5C               [ 2]  978 	incw	x
      000407 1F 01            [ 2]  979 	ldw	(0x01, sp), x
      000409 1E 01            [ 2]  980 	ldw	x, (0x01, sp)
      00040B A3 00 08         [ 2]  981 	cpw	x, #0x0008
      00040E 2F CA            [ 1]  982 	jrslt	00105$
      000410 5B 02            [ 2]  983 	addw	sp, #2
      000412 81               [ 4]  984 	ret
                                    985 ;	sensors.c: 363: void _tm1637ClkHigh(void)
                                    986 ;	-----------------------------------------
                                    987 ;	 function _tm1637ClkHigh
                                    988 ;	-----------------------------------------
      000413                        989 __tm1637ClkHigh:
                                    990 ;	sensors.c: 368: PD_ODR |= 1 << 2;
      000413 AE 50 0F         [ 2]  991 	ldw	x, #0x500f
      000416 F6               [ 1]  992 	ld	a, (x)
      000417 AA 04            [ 1]  993 	or	a, #0x04
      000419 F7               [ 1]  994 	ld	(x), a
      00041A 81               [ 4]  995 	ret
                                    996 ;	sensors.c: 371: void _tm1637ClkLow(void)
                                    997 ;	-----------------------------------------
                                    998 ;	 function _tm1637ClkLow
                                    999 ;	-----------------------------------------
      00041B                       1000 __tm1637ClkLow:
                                   1001 ;	sensors.c: 375: PD_ODR &= ~(1 << 2);
      00041B AE 50 0F         [ 2] 1002 	ldw	x, #0x500f
      00041E F6               [ 1] 1003 	ld	a, (x)
      00041F A4 FB            [ 1] 1004 	and	a, #0xfb
      000421 F7               [ 1] 1005 	ld	(x), a
      000422 81               [ 4] 1006 	ret
                                   1007 ;	sensors.c: 381: void _tm1637DioHigh(void)
                                   1008 ;	-----------------------------------------
                                   1009 ;	 function _tm1637DioHigh
                                   1010 ;	-----------------------------------------
      000423                       1011 __tm1637DioHigh:
                                   1012 ;	sensors.c: 385: PD_ODR |= 1 << 3;
      000423 AE 50 0F         [ 2] 1013 	ldw	x, #0x500f
      000426 F6               [ 1] 1014 	ld	a, (x)
      000427 AA 08            [ 1] 1015 	or	a, #0x08
      000429 F7               [ 1] 1016 	ld	(x), a
      00042A 81               [ 4] 1017 	ret
                                   1018 ;	sensors.c: 389: void _tm1637DioLow(void)
                                   1019 ;	-----------------------------------------
                                   1020 ;	 function _tm1637DioLow
                                   1021 ;	-----------------------------------------
      00042B                       1022 __tm1637DioLow:
                                   1023 ;	sensors.c: 391: PD_ODR &= ~(1 << 3);
      00042B AE 50 0F         [ 2] 1024 	ldw	x, #0x500f
      00042E F6               [ 1] 1025 	ld	a, (x)
      00042F A4 F7            [ 1] 1026 	and	a, #0xf7
      000431 F7               [ 1] 1027 	ld	(x), a
      000432 81               [ 4] 1028 	ret
                                   1029 ;	sensors.c: 400: unsigned int clock(void)
                                   1030 ;	-----------------------------------------
                                   1031 ;	 function clock
                                   1032 ;	-----------------------------------------
      000433                       1033 _clock:
      000433 52 03            [ 2] 1034 	sub	sp, #3
                                   1035 ;	sensors.c: 402: unsigned char h = TIM1_CNTRH; //origineel PCNTRH
      000435 AE 52 5E         [ 2] 1036 	ldw	x, #0x525e
      000438 F6               [ 1] 1037 	ld	a, (x)
                                   1038 ;	sensors.c: 403: unsigned char l = TIM1_CNTRL;
      000439 AE 52 5F         [ 2] 1039 	ldw	x, #0x525f
      00043C 88               [ 1] 1040 	push	a
      00043D F6               [ 1] 1041 	ld	a, (x)
      00043E 6B 02            [ 1] 1042 	ld	(0x02, sp), a
      000440 84               [ 1] 1043 	pop	a
                                   1044 ;	sensors.c: 404: return((unsigned int)(h) << 8 | l);
      000441 5F               [ 1] 1045 	clrw	x
      000442 97               [ 1] 1046 	ld	xl, a
      000443 58               [ 2] 1047 	sllw	x
      000444 58               [ 2] 1048 	sllw	x
      000445 58               [ 2] 1049 	sllw	x
      000446 58               [ 2] 1050 	sllw	x
      000447 58               [ 2] 1051 	sllw	x
      000448 58               [ 2] 1052 	sllw	x
      000449 58               [ 2] 1053 	sllw	x
      00044A 58               [ 2] 1054 	sllw	x
      00044B 7B 01            [ 1] 1055 	ld	a, (0x01, sp)
      00044D 6B 03            [ 1] 1056 	ld	(0x03, sp), a
      00044F 0F 02            [ 1] 1057 	clr	(0x02, sp)
      000451 9F               [ 1] 1058 	ld	a, xl
      000452 1A 03            [ 1] 1059 	or	a, (0x03, sp)
      000454 97               [ 1] 1060 	ld	xl, a
      000455 9E               [ 1] 1061 	ld	a, xh
      000456 1A 02            [ 1] 1062 	or	a, (0x02, sp)
      000458 95               [ 1] 1063 	ld	xh, a
      000459 5B 03            [ 2] 1064 	addw	sp, #3
      00045B 81               [ 4] 1065 	ret
                                   1066 ;	sensors.c: 453: void rt_one_second_increment (st_time *t) {
                                   1067 ;	-----------------------------------------
                                   1068 ;	 function rt_one_second_increment
                                   1069 ;	-----------------------------------------
      00045C                       1070 _rt_one_second_increment:
                                   1071 ;	sensors.c: 454: if(++t->second > 59) {
      00045C 16 03            [ 2] 1072 	ldw	y, (0x03, sp)
      00045E 90 F6            [ 1] 1073 	ld	a, (y)
      000460 4C               [ 1] 1074 	inc	a
      000461 90 F7            [ 1] 1075 	ld	(y), a
      000463 A1 3B            [ 1] 1076 	cp	a, #0x3b
      000465 23 17            [ 2] 1077 	jrule	00107$
                                   1078 ;	sensors.c: 455: t->second= 0;
      000467 90 7F            [ 1] 1079 	clr	(y)
                                   1080 ;	sensors.c: 456: if(++t->minute > 59) {
      000469 93               [ 1] 1081 	ldw	x, y
      00046A 5C               [ 2] 1082 	incw	x
      00046B F6               [ 1] 1083 	ld	a, (x)
      00046C 4C               [ 1] 1084 	inc	a
      00046D F7               [ 1] 1085 	ld	(x), a
      00046E A1 3B            [ 1] 1086 	cp	a, #0x3b
      000470 23 0C            [ 2] 1087 	jrule	00107$
                                   1088 ;	sensors.c: 457: t->minute= 0;
      000472 7F               [ 1] 1089 	clr	(x)
                                   1090 ;	sensors.c: 458: if(++t->hour > 23) {
      000473 93               [ 1] 1091 	ldw	x, y
      000474 5C               [ 2] 1092 	incw	x
      000475 5C               [ 2] 1093 	incw	x
      000476 F6               [ 1] 1094 	ld	a, (x)
      000477 4C               [ 1] 1095 	inc	a
      000478 F7               [ 1] 1096 	ld	(x), a
      000479 A1 17            [ 1] 1097 	cp	a, #0x17
      00047B 23 01            [ 2] 1098 	jrule	00107$
                                   1099 ;	sensors.c: 459: t->hour= 0;
      00047D 7F               [ 1] 1100 	clr	(x)
      00047E                       1101 00107$:
      00047E 81               [ 4] 1102 	ret
                                   1103 ;	sensors.c: 469: void timer_isr(void) __interrupt(BEEP_ISR) {
                                   1104 ;	-----------------------------------------
                                   1105 ;	 function timer_isr
                                   1106 ;	-----------------------------------------
      00047F                       1107 _timer_isr:
                                   1108 ;	sensors.c: 470: if (++internteller > 500) {
      00047F CEu00u04         [ 2] 1109 	ldw	x, _internteller+0
      000482 5C               [ 2] 1110 	incw	x
      000483 CFu00u04         [ 2] 1111 	ldw	_internteller+0, x
      000486 A3 01 F4         [ 2] 1112 	cpw	x, #0x01f4
      000489 23 11            [ 2] 1113 	jrule	00103$
                                   1114 ;	sensors.c: 471: internteller=0;
      00048B 72 5Fu00u05      [ 1] 1115 	clr	_internteller+1
      00048F 72 5Fu00u04      [ 1] 1116 	clr	_internteller+0
                                   1117 ;	sensors.c: 472: rt_one_second_increment(&real_time);
      000493 AEr00r00         [ 2] 1118 	ldw	x, #_real_time+0
      000496 89               [ 2] 1119 	pushw	x
      000497 CDr04r5C         [ 4] 1120 	call	_rt_one_second_increment
      00049A 5B 02            [ 2] 1121 	addw	sp, #2
      00049C                       1122 00103$:
      00049C 80               [11] 1123 	iret
                                   1124 ;	sensors.c: 485: int main () {
                                   1125 ;	-----------------------------------------
                                   1126 ;	 function main
                                   1127 ;	-----------------------------------------
      00049D                       1128 _main:
      00049D 52 02            [ 2] 1129 	sub	sp, #2
                                   1130 ;	sensors.c: 492: InitializeSystemClock();
      00049F CDr00r08         [ 4] 1131 	call	_InitializeSystemClock
                                   1132 ;	sensors.c: 494: BEEP_CSR = (0<<7) | (0<<6) | (1<<5) | 0x1E;
      0004A2 AE 50 F3         [ 2] 1133 	ldw	x, #0x50f3
      0004A5 A6 3E            [ 1] 1134 	ld	a, #0x3e
      0004A7 F7               [ 1] 1135 	ld	(x), a
                                   1136 ;	sensors.c: 495: PD_DDR = (1 << 3) | (1 << 2); // output mode
      0004A8 AE 50 11         [ 2] 1137 	ldw	x, #0x5011
      0004AB A6 0C            [ 1] 1138 	ld	a, #0x0c
      0004AD F7               [ 1] 1139 	ld	(x), a
                                   1140 ;	sensors.c: 497: PD_DDR &=  ~(1 << 4); //PD4 input
      0004AE AE 50 11         [ 2] 1141 	ldw	x, #0x5011
      0004B1 F6               [ 1] 1142 	ld	a, (x)
      0004B2 A4 EF            [ 1] 1143 	and	a, #0xef
      0004B4 F7               [ 1] 1144 	ld	(x), a
                                   1145 ;	sensors.c: 498: PD_CR1 = (1 << 3) | (1 << 2); // push-pull
      0004B5 AE 50 12         [ 2] 1146 	ldw	x, #0x5012
      0004B8 A6 0C            [ 1] 1147 	ld	a, #0x0c
      0004BA F7               [ 1] 1148 	ld	(x), a
                                   1149 ;	sensors.c: 499: PD_CR1 &= ~(1 << 4); // input with float
      0004BB AE 50 12         [ 2] 1150 	ldw	x, #0x5012
      0004BE F6               [ 1] 1151 	ld	a, (x)
      0004BF A4 EF            [ 1] 1152 	and	a, #0xef
      0004C1 F7               [ 1] 1153 	ld	(x), a
                                   1154 ;	sensors.c: 500: PD_CR2 = (1 << 3) | (1 << 2) | (1<< 4); // up to 10MHz speed + interrupt enabled 
      0004C2 AE 50 13         [ 2] 1155 	ldw	x, #0x5013
      0004C5 A6 1C            [ 1] 1156 	ld	a, #0x1c
      0004C7 F7               [ 1] 1157 	ld	(x), a
                                   1158 ;	sensors.c: 502: EXTI_CR1 = (1<<7); //Port D external sensitivity bits7:6 10: Falling edge only
      0004C8 AE 50 A0         [ 2] 1159 	ldw	x, #0x50a0
      0004CB A6 80            [ 1] 1160 	ld	a, #0x80
      0004CD F7               [ 1] 1161 	ld	(x), a
                                   1162 ;	sensors.c: 503: EXTI_CR1 &= ~(1<<6); //Port D external sensitivity bits7:6 10: Falling edge only
      0004CE AE 50 A0         [ 2] 1163 	ldw	x, #0x50a0
      0004D1 F6               [ 1] 1164 	ld	a, (x)
      0004D2 A4 BF            [ 1] 1165 	and	a, #0xbf
      0004D4 F7               [ 1] 1166 	ld	(x), a
                                   1167 ;	sensors.c: 506: tijd = &real_time;
      0004D5 AEr00r00         [ 2] 1168 	ldw	x, #_real_time+0
      0004D8 1F 01            [ 2] 1169 	ldw	(0x01, sp), x
                                   1170 ;	sensors.c: 510: TIM1_PSCRH = 0x3e;
      0004DA AE 52 60         [ 2] 1171 	ldw	x, #0x5260
      0004DD A6 3E            [ 1] 1172 	ld	a, #0x3e
      0004DF F7               [ 1] 1173 	ld	(x), a
                                   1174 ;	sensors.c: 511: TIM1_PSCRL = 0x80;
      0004E0 AE 52 61         [ 2] 1175 	ldw	x, #0x5261
      0004E3 A6 80            [ 1] 1176 	ld	a, #0x80
      0004E5 F7               [ 1] 1177 	ld	(x), a
                                   1178 ;	sensors.c: 513: tm1637Init();
      0004E6 CDr02rCF         [ 4] 1179 	call	_tm1637Init
                                   1180 ;	sensors.c: 515: InitializeUART();
      0004E9 CDr02r56         [ 4] 1181 	call	_InitializeUART
                                   1182 ;	sensors.c: 518: __asm__("rim");
      0004EC 9A               [ 1] 1183 	rim
                                   1184 ;	sensors.c: 522: while (1) {
      0004ED                       1185 00102$:
                                   1186 ;	sensors.c: 525: tm1637DisplayDecimal(tijd->minute, 0); // display minutes 
      0004ED 1E 01            [ 2] 1187 	ldw	x, (0x01, sp)
      0004EF E6 01            [ 1] 1188 	ld	a, (0x1, x)
      0004F1 5F               [ 1] 1189 	clrw	x
      0004F2 89               [ 2] 1190 	pushw	x
      0004F3 88               [ 1] 1191 	push	a
      0004F4 CDr02rD6         [ 4] 1192 	call	_tm1637DisplayDecimal
      0004F7 5B 03            [ 2] 1193 	addw	sp, #3
      0004F9 20 F2            [ 2] 1194 	jra	00102$
      0004FB 5B 02            [ 2] 1195 	addw	sp, #2
      0004FD 81               [ 4] 1196 	ret
                                   1197 	.area CODE
      0004FE                       1198 _segmentMap:
      0004FE 3F                    1199 	.db #0x3F	;  63
      0004FF 06                    1200 	.db #0x06	;  6
      000500 5B                    1201 	.db #0x5B	;  91
      000501 4F                    1202 	.db #0x4F	;  79	'O'
      000502 66                    1203 	.db #0x66	;  102	'f'
      000503 6D                    1204 	.db #0x6D	;  109	'm'
      000504 7D                    1205 	.db #0x7D	;  125
      000505 07                    1206 	.db #0x07	;  7
      000506 7F                    1207 	.db #0x7F	;  127
      000507 6F                    1208 	.db #0x6F	;  111	'o'
      000508 77                    1209 	.db #0x77	;  119	'w'
      000509 7C                    1210 	.db #0x7C	;  124
      00050A 39                    1211 	.db #0x39	;  57	'9'
      00050B 5E                    1212 	.db #0x5E	;  94
      00050C 79                    1213 	.db #0x79	;  121	'y'
      00050D 71                    1214 	.db #0x71	;  113	'q'
      00050E 00                    1215 	.db #0x00	;  0
                                   1216 	.area INITIALIZER
                                   1217 	.area CABS (ABS)
